function m(c){const e=document.createElement("span");return e.setAttribute("class","material-symbols-outlined"),e.textContent=c,e}function k(c,e,t,o){const n=document.createElement("a");{const r=m(o);n.appendChild(r)}return n.setAttribute("href",e),n.setAttribute("target","_blank"),n.textContent=c,n}function E(c){const e=c.reduce((o,n)=>{const r=document.createElement("option");return r.textContent=n.toString(),r.setAttribute("value",n.toString()),o.appendChild(r),o},document.createElement("select")),t=document.createElement("option");return t.textContent="All Years",t.setAttribute("value","0"),t.selected=!0,e.prepend(t),e}function S(c,e){const t=document.createElement(c);return t.textContent=e,t}const h="MyBookDB",l="books",u="metadata",g=1,b=11;class f{db=null;async open(){return this.db?this.db:new Promise((e,t)=>{const o=indexedDB.open(h,g);o.onerror=()=>{console.error("Error opening IndexedDB:",o.error),t(o.error)},o.onupgradeneeded=n=>{const r=n.target.result;if(!r.objectStoreNames.contains(l)){const i=r.createObjectStore(l,{keyPath:"id"});i.createIndex("title","bookTitle",{unique:!1}),i.createIndex("authors","authors",{unique:!1,multiEntry:!0}),i.createIndex("dateRead","dateRead",{unique:!1}),console.log(`Object store '${l}' created with indexes.`)}r.objectStoreNames.contains(u)||(r.createObjectStore(u,{keyPath:"key"}),console.log("Metadata store created.")),console.log("IndexedDB schema update complete.")},o.onsuccess=()=>{this.db=o.result,e(this.db)}})}async _getMetadata(e){const t=await this.open();return new Promise((o,n)=>{const a=t.transaction([u],"readonly").objectStore(u).get(e);a.onsuccess=()=>{o(a.result?a.result.value:void 0)},a.onerror=()=>n(a.error)})}async initializeData(){try{const e=await this._getMetadata("data_version")||0;if(e>=b){console.log(`Data is already up-to-date (v${e}). Skipping import.`);return}console.log(`Data version is outdated (v${e}). Fetching books from books.json (v${b})...`);const t=await fetch("https://raw.githubusercontent.com/RyanMontville/reading-list/refs/heads/main/data/books.json");if(!t.ok)throw new Error(`Failed to fetch books.json: ${t.status} ${t.statusText}`);const o=await t.json();o.forEach(s=>{typeof s.dateRead=="string"&&(s.dateRead=new Date(s.dateRead))});const r=(await this.open()).transaction([l,u],"readwrite"),i=r.objectStore(l),a=r.objectStore(u);return o.forEach(s=>{i.put(s).onerror=d=>{console.error(`Error processing book ${s.isbn}:`,d.target.error)}}),a.put({key:"data_version",value:b}),new Promise((s,d)=>{r.oncomplete=()=>{console.log(`Successfully merged ${o.length} books and updated data version to ${b}.`),s()},r.onerror=p=>{console.error("Transaction failed during bulk import:",p.target.error),d(p.target.error)}})}catch(e){throw console.error("Failed to initialize database data:",e),e}}async getAllBooks(){const e=await this.open(),t=[];return new Promise((o,n)=>{const a=e.transaction([l],"readonly").objectStore(l).openCursor();a.onsuccess=s=>{const d=s.target.result;d?(t.push(d.value),d.continue()):o(t)},a.onerror=()=>{console.error("Error retrieving all books:",a.error),n(a.error)}})}}const w=new f;export{S as a,w as b,k as c,E as d};
