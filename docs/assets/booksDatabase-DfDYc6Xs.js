function h(l){const e=document.createElement("span");return e.setAttribute("class","material-symbols-outlined"),e.textContent=l,e}function f(l,e,o,t){const n=document.createElement("a");{const r=h(t);n.appendChild(r)}return n.setAttribute("href",e),n.setAttribute("target","_blank"),n.textContent=l,n}function S(l){const e=l.reduce((t,n)=>{const r=document.createElement("option");return r.textContent=n.toString(),r.setAttribute("value",n.toString()),t.appendChild(r),t},document.createElement("select")),o=document.createElement("option");return o.textContent="All Years",o.setAttribute("value","0"),o.selected=!0,e.prepend(o),e}const g="MyBookDB",d="books",u="metadata",m=1,b=11;class k{db=null;async open(){return this.db?this.db:new Promise((e,o)=>{const t=indexedDB.open(g,m);t.onerror=()=>{console.error("Error opening IndexedDB:",t.error),o(t.error)},t.onupgradeneeded=n=>{const r=n.target.result;if(!r.objectStoreNames.contains(d)){const c=r.createObjectStore(d,{keyPath:"id"});c.createIndex("title","bookTitle",{unique:!1}),c.createIndex("authors","authors",{unique:!1,multiEntry:!0}),c.createIndex("dateRead","dateRead",{unique:!1}),console.log(`Object store '${d}' created with indexes.`)}r.objectStoreNames.contains(u)||(r.createObjectStore(u,{keyPath:"key"}),console.log("Metadata store created.")),console.log("IndexedDB schema update complete.")},t.onsuccess=()=>{this.db=t.result,e(this.db)}})}async _getMetadata(e){const o=await this.open();return new Promise((t,n)=>{const a=o.transaction([u],"readonly").objectStore(u).get(e);a.onsuccess=()=>{t(a.result?a.result.value:void 0)},a.onerror=()=>n(a.error)})}async initializeData(){try{const e=await this._getMetadata("data_version")||0;if(e>=b){console.log(`Data is already up-to-date (v${e}). Skipping import.`);return}console.log(`Data version is outdated (v${e}). Fetching books from books.json (v${b})...`);const o=await fetch("https://raw.githubusercontent.com/RyanMontville/reading-list/refs/heads/main/data/books.json");if(!o.ok)throw new Error(`Failed to fetch books.json: ${o.status} ${o.statusText}`);const t=await o.json();t.forEach(s=>{typeof s.dateRead=="string"&&(s.dateRead=new Date(s.dateRead))});const r=(await this.open()).transaction([d,u],"readwrite"),c=r.objectStore(d),a=r.objectStore(u);return t.forEach(s=>{c.put(s).onerror=i=>{console.error(`Error processing book ${s.isbn}:`,i.target.error)}}),a.put({key:"data_version",value:b}),new Promise((s,i)=>{r.oncomplete=()=>{console.log(`Successfully merged ${t.length} books and updated data version to ${b}.`),s()},r.onerror=p=>{console.error("Transaction failed during bulk import:",p.target.error),i(p.target.error)}})}catch(e){throw console.error("Failed to initialize database data:",e),e}}async getAllBooks(){const e=await this.open(),o=[];return new Promise((t,n)=>{const a=e.transaction([d],"readonly").objectStore(d).openCursor();a.onsuccess=s=>{const i=s.target.result;i?(o.push(i.value),i.continue()):t(o)},a.onerror=()=>{console.error("Error retrieving all books:",a.error),n(a.error)}})}}const E=new k;export{S as a,E as b,f as c};
