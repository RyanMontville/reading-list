function h(c){const e=document.createElement("span");return e.setAttribute("class","material-symbols-outlined"),e.textContent=c,e}function k(c,e,o,t){const r=document.createElement("a");{const n=h(t);r.appendChild(n)}return r.setAttribute("href",e),r.setAttribute("target","_blank"),r.textContent=c,r}function E(c){const e=c.reduce((o,t)=>{const r=document.createElement("option");return r.textContent=t.toString(),r.setAttribute("value",t.toString()),o.appendChild(r),o},document.createElement("select"));return e.options[e.length-1].selected=!0,e}function S(c,e){const o=document.createElement(c);return o.textContent=e,o}const g="MyBookDB",l="books",u="metadata",m=1,b=11;class f{db=null;async open(){return this.db?this.db:new Promise((e,o)=>{const t=indexedDB.open(g,m);t.onerror=()=>{console.error("Error opening IndexedDB:",t.error),o(t.error)},t.onupgradeneeded=r=>{const n=r.target.result;if(!n.objectStoreNames.contains(l)){const i=n.createObjectStore(l,{keyPath:"id"});i.createIndex("title","bookTitle",{unique:!1}),i.createIndex("authors","authors",{unique:!1,multiEntry:!0}),i.createIndex("dateRead","dateRead",{unique:!1}),console.log(`Object store '${l}' created with indexes.`)}n.objectStoreNames.contains(u)||(n.createObjectStore(u,{keyPath:"key"}),console.log("Metadata store created.")),console.log("IndexedDB schema update complete.")},t.onsuccess=()=>{this.db=t.result,e(this.db)}})}async _getMetadata(e){const o=await this.open();return new Promise((t,r)=>{const a=o.transaction([u],"readonly").objectStore(u).get(e);a.onsuccess=()=>{t(a.result?a.result.value:void 0)},a.onerror=()=>r(a.error)})}async initializeData(){try{const e=await this._getMetadata("data_version")||0;if(e>=b){console.log(`Data is already up-to-date (v${e}). Skipping import.`);return}console.log(`Data version is outdated (v${e}). Fetching books from books.json (v${b})...`);const o=await fetch("https://raw.githubusercontent.com/RyanMontville/reading-list/refs/heads/main/data/books.json");if(!o.ok)throw new Error(`Failed to fetch books.json: ${o.status} ${o.statusText}`);const t=await o.json();t.forEach(s=>{typeof s.dateRead=="string"&&(s.dateRead=new Date(s.dateRead))});const n=(await this.open()).transaction([l,u],"readwrite"),i=n.objectStore(l),a=n.objectStore(u);return t.forEach(s=>{i.put(s).onerror=d=>{console.error(`Error processing book ${s.isbn}:`,d.target.error)}}),a.put({key:"data_version",value:b}),new Promise((s,d)=>{n.oncomplete=()=>{console.log(`Successfully merged ${t.length} books and updated data version to ${b}.`),s()},n.onerror=p=>{console.error("Transaction failed during bulk import:",p.target.error),d(p.target.error)}})}catch(e){throw console.error("Failed to initialize database data:",e),e}}async getAllBooks(){const e=await this.open(),o=[];return new Promise((t,r)=>{const a=e.transaction([l],"readonly").objectStore(l).openCursor();a.onsuccess=s=>{const d=s.target.result;d?(o.push(d.value),d.continue()):t(o)},a.onerror=()=>{console.error("Error retrieving all books:",a.error),r(a.error)}})}}const w=new f;export{S as a,w as b,k as c,E as d};
