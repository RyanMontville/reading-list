function D(s,t){const r=document.createElement(s);return r.textContent=t,r}function k(s){const t=document.createElement("span");return t.setAttribute("class","material-symbols-outlined"),t.textContent=s,t}function y(s,t,r,o){const n=document.createElement("a");{const a=k(o);n.appendChild(a)}return n.setAttribute("href",t),n.setAttribute("target","_blank"),n.textContent=s,n}function x(s){const t=s.reduce((r,o)=>{const n=document.createElement("option");return n.textContent=o.toString(),n.setAttribute("value",o.toString()),r.appendChild(n),r},document.createElement("select"));return t.options[t.length-1].selected=!0,t}function j(s){const t=document.createElement("div");t.setAttribute("class","book");const r=document.createElement("img");r.setAttribute("src",s.cover),t.appendChild(r);const o=document.createElement("section"),n=document.createElement("h3");n.textContent=s.bookTitle,o.appendChild(n);const a=s.authors.reduce((p,h)=>{const d=document.createElement("a");d.addEventListener("click",()=>window.location.href=`/reading-list/?author=${h}`);let c=document.createTextNode(h);return d.appendChild(c),p.appendChild(d),p},document.createElement("h4"));o.appendChild(a);const i=document.createElement("p"),e=new Date(s.dateRead);i.textContent=`Date Read: ${e.toLocaleString("default",{month:"long"})} ${e.getFullYear()}`,o.appendChild(i);const g=s.tags.reduce((p,h)=>{const d=document.createElement("li"),c=document.createTextNode(h);return d.addEventListener("click",()=>window.location.href=`/reading-list/?tag=${h}`),d.appendChild(c),p.appendChild(d),p},document.createElement("ul"));o.appendChild(g);const l=y("View on StoryGraph",s.moreInfo,!0,"open_in_new");return o.appendChild(l),t.appendChild(o),t}const C="MyBookDB",u="books",b="challenges",E="metadata",S=2,w=13;class v{db=null;async open(){return this.db?this.db:new Promise((t,r)=>{const o=indexedDB.open(C,S);o.onerror=()=>{console.error("Error opening IndexedDB:",o.error),r(o.error)},o.onupgradeneeded=n=>{const a=n.target.result,i=n.oldVersion;if(i<1){if(!a.objectStoreNames.contains(u)){const e=a.createObjectStore(u,{keyPath:"id"});e.createIndex("title","bookTitle",{unique:!1}),e.createIndex("authors","authors",{unique:!1,multiEntry:!0}),e.createIndex("dateRead","dateRead",{unique:!1}),console.log(`Object store '${u}' created with indexes.`)}a.objectStoreNames.contains(E)||(a.createObjectStore(E,{keyPath:"key"}),console.log("Metadata store created."))}if(i<2&&!a.objectStoreNames.contains(b)){const e=a.createObjectStore(b,{keyPath:"id",autoIncrement:!0});e.createIndex("challengeName","challengeName",{unique:!1}),e.createIndex("startDate","startDate",{unique:!1}),e.createIndex("endDate","endDate",{unique:!1}),e.createIndex("goal","goal",{unique:!1}),console.log(`New object store '${b}' created.`)}console.log(`IndexedDB schema update complete. Old version: ${i}, New version: ${S}`)},o.onsuccess=()=>{this.db=o.result,t(this.db)}})}async _getMetadata(t){const r=await this.open();return new Promise((o,n)=>{const e=r.transaction([E],"readonly").objectStore(E).get(t);e.onsuccess=()=>{o(e.result?e.result.value:void 0)},e.onerror=()=>n(e.error)})}async initializeData(){try{const t=await this._getMetadata("data_version")||0;if(t>=w){console.log(`Data is already up-to-date (v${t}). Skipping import.`);return}console.log(`Data version is outdated (v${t}). Fetching data (v${w})...`);const r=await fetch("https://raw.githubusercontent.com/RyanMontville/reading-list/refs/heads/main/data/books.json");if(!r.ok)throw new Error(`Failed to fetch books.json: ${r.status} ${r.statusText}`);const o=await r.json();o.forEach(c=>{typeof c.dateRead=="string"&&(c.dateRead=new Date(c.dateRead))});const n=await fetch("https://raw.githubusercontent.com/RyanMontville/reading-list/refs/heads/main/data/challenges.json");if(!n.ok)throw new Error(`Failed to fetch challenges.json: ${n.status} ${n.statusText}`);const a=await n.json(),e=(await this.open()).transaction([u,b,E],"readwrite"),g=e.objectStore(u),l=e.objectStore(b),p=e.objectStore(E);let h=0;o.forEach(c=>{const m=g.put(c);m.onsuccess=()=>{h++},m.onerror=f=>{console.error(`Error processing book ${c.id}:`,f.target.error)}});let d=0;return a.forEach(c=>{const m=l.put(c);m.onsuccess=()=>{d++},m.onerror=f=>{console.error(`Error processing challenge ${c.id}:`,f.target.error)}}),p.put({key:"data_version",value:w}),new Promise((c,m)=>{e.oncomplete=()=>{console.log(`Successfully merged ${h} books and ${d} challenges.`),console.log(`Updated data version to ${w}.`),c()},e.onerror=f=>{console.error("Transaction failed during bulk import:",f.target.error),m(f.target.error)}})}catch(t){throw console.error("Failed to initialize database data:",t),t}}async getAllBooks(){const t=await this.open(),r=[];return new Promise((o,n)=>{const e=t.transaction([u],"readonly").objectStore(u).openCursor();e.onsuccess=g=>{const l=g.target.result;l?(r.push(l.value),l.continue()):o(r)},e.onerror=()=>{console.error("Error retrieving all books:",e.error),n(e.error)}})}async getAllChallenges(){const t=await this.open(),r=[];return new Promise((o,n)=>{const e=t.transaction([b],"readonly").objectStore(b).openCursor();e.onsuccess=g=>{const l=g.target.result;l?(r.push(l.value),l.continue()):o(r)},e.onerror=()=>{console.error("Error retrieving all challenges:",e.error),n(e.error)}})}async getBookById(t){const r=await this.open();return new Promise((o,n)=>{const e=r.transaction([u],"readonly").objectStore(u).get(t);e.onsuccess=()=>{o(e.result)},e.onerror=()=>{console.error(`Error retrieving book with ID ${t}:`,e.error),n(e.error)}})}}const $=new v;export{D as a,$ as b,j as c,x as d};
